<?php

/**
 * @file
 * drushsubtree drush command.
 *
 *  You can copy this file to any of the following
 *    1. A .drush folder in your HOME folder.
 *    2. Anywhere in a folder tree below an active module on your site.
 *    3. /usr/share/drush/commands (configurable)
 *    4. In an arbitrary folder specified with the --include option.
 *    5. Drupal's /drush or /sites/all/drush folders.
 */

require_once 'drushsubtree.subtreecommander.class.inc';

/**
 * Implements hook_drush_command().
 */
function drushsubtree_drush_command() {
  $items = array();
  $standard_command_options = _drushsubtree_standard_command_options();

  // TODO Add this:
  /*
  $items['subtree-remote'] = array(
  // */

  $items['subtree'] = array(
    'description' => 'An interface for running drushsubtree commands with more git-like syntax. (All options for all commands are supported. See `drush subtree-<command>` --help for documentation about options for particular commands.)',
    'arguments' => array(
      'command' => '',
      'project' => '',
    ),
    'options' => $standard_command_options,
    'examples' => array(
      'drush subtree <command> <project>' => '',
      'drush subtree add <project>' => '',
      'drush subtree pull <project>' => '',
      'drush subtree push <project>' => '',
      'drush subtree merge <project> <id>' => '',
      'drush subtree checkout <project> <tag>' => '',
    ),
    // No bootstrap at all.
    'bootstrap' => DRUSH_BOOTSTRAP_DRUSH,
    'drush dependencies' => 'buildmanager',
  );

  $items['subtree-add'] = array(
    'description' => '',
    'arguments' => array(
      'project' => '(Optional) Subtree defined in buildmanager config.',
    ),
    'options' => $standard_command_options,
    'examples' => array(
      'drush subtree-add' => '',
    ),
    // No bootstrap at all.
    'bootstrap' => DRUSH_BOOTSTRAP_DRUSH,
    'drush dependencies' => 'buildmanager',
  );

  $items['subtree-pull'] = array(
    'description' => '',
    'arguments' => array(
      'project' => '(Optional) Subtree defined in buildmanager config.',
    ),
    'options' => $standard_command_options,
    'examples' => array(
      'drush subtree-pull' => '',
    ),
    // No bootstrap at all.
    'bootstrap' => DRUSH_BOOTSTRAP_DRUSH,
    'drush dependencies' => 'buildmanager',
  );

  $items['subtree-merge'] = array(
    'description' => '',
    'arguments' => array(
      'project' => '(Optional) Specify a subtree defined in buildmanager config.',
      'commit ID' => '(Optional) Override ID/tag specified in make file(s).',
    ),
    'options' => $standard_command_options,
    'examples' => array(
      'drush subtree-merge' => '',
      'drush subtree-merge <my project>' => '',
      'drush subtree-merge <my project> <commit id>' => '',
    ),
    // No bootstrap at all.
    'bootstrap' => DRUSH_BOOTSTRAP_DRUSH,
    'drush dependencies' => 'buildmanager',
  );

  $push_options = $standard_command_options;
  unset($push_options['message']);
  $items['subtree-push'] = array(
    'description' => '',
    'arguments' => array(
      'project' => '',
    ),
    'options' => $push_options,
    'examples' => array(
      'drush subtree-push' => '',
    ),
    // No bootstrap at all.
    'bootstrap' => DRUSH_BOOTSTRAP_DRUSH,
    'drush dependencies' => 'buildmanager',
  );

  $items['subtree-checkout'] = array(
    'description' => 'Faux subtree command. "Checkout" a tagged version of a subtree project.',
    'arguments' => array(
      'project' => '',
      'tag or commit ID' => 'Git tag or commit ID. (Check available tags with drushsubtree-get-tags. Commit IDs must be passed as full 40 character SHA1 hash. 40 character tags are not supported.)',
    ),
    'options' => $standard_command_options,
    'examples' => array(
      'drush subtree-checkout <project> <id>' => '',
      'drush subtree-checkout <project> <tag>' => '',
    ),
    // No bootstrap at all.
    'bootstrap' => DRUSH_BOOTSTRAP_DRUSH,
    'drush dependencies' => 'buildmanager',
  );

  $items['subtree-get-tags'] = array(
    'description' => "View tagged releases for a subtree project.",
    'arguments' => array(
      'project_name' => '',
    ),
    'examples' => array(
      'drush subtree-get-tags <my-project>' => '',
      'drush subtree-ls-tags <my-project>' => '',
    ),
    'aliases' => array('subtree-ls-tags'),
    // No bootstrap at all.
    'bootstrap' => DRUSH_BOOTSTRAP_DRUSH,
    'drush dependencies' => 'buildmanager',
  );

  return $items;
}

/**
 * Returns array of standard subtree options, used for multiple commands.
 *
 * @return array
 *   Options to be used in any command following pattern drush subtree <command>
 */
function _drushsubtree_standard_command_options() {
  return array(
    'config_file' => array(
      'description' => 'path/to/buildmaster.config.yml',
    ),
    'message' => array(
      'description' => 'Message to include at the beginning of new commits. (Note: subtree add, merge, pull all generate commits in your parent repo.)',
    ),
    'simulate' => array(
      'description' => 'Output commands to be executed for examination, but do not actually execute them.',
    ),
  );
}

/**
 * Callback for drushsubtree-get-tags().
 */
function drush_drushsubtree_subtree_get_tags($subtree_name) {
  // Get config.
  $config = _drushsubtree_get_config();
  if (!$details = $config['subtrees'][$subtree_name]) {
    drush_set_error(dt('No subtree config available for !subtree in !config_file'),
      array('!subtree' => $subtree_name, '!config_file' => $config_file));
  }

  // Look up tags from remote specified in $details.
  $tags = drushsubtree_list_remote_tags($subtree_name, $details);

  foreach ($tags as $tag => $id) {
    drush_print("{$tag}\t{$id}");
  }
}


/**
 * Get message to be included with subtree add/pull/merge commits.
 *
 * Site make config files can specify a message to be included
 * project-by-project.
 *
 * @param string $subtree_message
 *   Defined in buildmanager YAML config file.
 *
 * @return string
 *   A commit message flag to a git subtree add, pull, or merge command.
 *   Empty string if no message should be added.
 */
function _drushsubtree_add_subtree_commit_message($subtree_message = '') {
  $drush_message = drush_get_option('message', '');
  if ($drush_message || $subtree_message) {
    $custom_message = ($drush_message) ? "{$drush_message}\n\n\t{$subtree_message}" : $subtree_message;
  }
  $message = ($custom_message) ? " --message='{$custom_message}'" : '';

  return $message;
}

/**
 * Get prefix (path) to local subtree.
 *
 * @param string $directory
 *   Name of directory where subtree should go.
 *
 * @return string
 *   Path to subtree from top-level of repo to be used for --prefix.
 */
function _drushsubtree_get_prefix($directory) {
  return "projects/{$directory}";
}

/**
 * Get URI for remote git repo.
 *
 * @param array $details
 *   Relevant details for git subtree add command.
 *
 * @return string|bool
 *   Uri for git repo.
 */
function _drushsubtree_get_uri($details) {
  if (!(isset($details['uri']) || !strlen($details['uri']) > 0)) {
    return drush_set_error('drushsubtree', dt("uri is a required subtree parameter for any subtree included here. Please add this to your site's config file, then try again."), 'error');
  }
  else {
    return $details['uri'];
  }
}

/**
 * Get subtree branch from drushsubtree project details included in config file.
 *
 * @param array $details
 *   Relevant details for git subtree add command:
 *
 * @return string|bool
 *   Branch name.
 */
function _drushsubtree_get_branch($details) {
  if (!(isset($details['branch']) || !strlen($details['branch']) > 0)) {
    return drush_set_error('drushsubtree', dt("branchis a required subtree parameter for any subtree included here. Please add this to your site's config file, then try again."), 'error');
  }

  return $details['branch'];
}
/**
 * Figure out what version of a subtree project should be checked out.
 *
 * Return commit ID so "checkout" can be done as a subtree merge.
 *
 * @param string $subtree_name
 *   Name of subtree.
 *
 * @param array $project_info
 *   Info about a project from parsed make files.
 *
 * @param array $details
 *   Details about subtree project from buildmanager config.
 *
 * @param string $tag
 *   Tag, if available. Empty if not.
 *
 * @return string
 *   Commit ID for subtree to be merged to. Empty if unavailable.
 */
function _drushsubtree_get_project_id($subtree_name, $project_info, $details, $tag = '') {
  $id = '';

  // First, try getting ID ("revision") from make files.
  $id = _drushsubtree_get_id_from_make_info($subtree_name, $project_info);

  // If no commit ID was specified in make file(s), try looking up ID using
  // remote list of tags.
  if (!$id) {
    // Get an array of commit IDs keyed by tags.
    $tags = drushsubtree_list_remote_tags($subtree_name, $details);
  }
  if (!$id && !$tags) {
    // Attempt to retrieved tags from remote failed.
    drush_log(dt("Commit IDs for !name tags could not be retrieved from !remote.\nTo explicitly designate which commit ID to check out, you can add this to your makefile (replace abc1234 with a real commit ID):\n\tprojects[!name][download][revision] = abc1234",
      array('!name' => $subtree_name, '!remote' => $details['uri'])), 'warning');
  }
  elseif ($tags && !$tag) {
    // Tags were retrieved successfully. No tag was passed in. See if we can get
    // tag/version from make file(s).
    $tag = _drushsubtree_get_project_tag($subtree_name, $project_info);
  }
  // If we've got an array of IDs keyed by tags ($tags) and a tag to look up
  // ($tags), we've got what we need now.
  if ($tags && $tag) {
    // Success!
    $id = $tags[$tag];
  }

  return $id;
}

/**
 * Get a commit ID ("revision") from a drush make file info.
 *
 * @param string $project_name
 *   Name of project (module, profile, theme, library).
 *
 * @param array $project_info
 *   Project info array from make files.
 *
 * @return string|bool
 *   Project revision (commit) id specified in make file. False if unavailable.
 */
function _drushsubtree_get_id_from_make_info($project_name, $project_info) {
  $id = (isset($project_info['download']['revision'])) ? $project_info['download']['revision'] : FALSE;
  return $id;
}

/**
 * Retrieve list of tags and corresponding commit IDs from remote repository.
 *
 * @param string $project_name
 *   Name of project (module, profile, theme, library).
 *
 * @param array $details
 *   From drushsubtree config.
 *
 * @return array|bool
 *   Commit IDs keyed by tag name. False for failure.
 */
function drushsubtree_list_remote_tags($project_name, $details) {
  // Get a list of commit IDs and corresponding tags. A successful request
  // returns something like this:
  // 516726690a5f3a15ccf8d7ffccd135db4375ad10  refs/tags/7.x-1.0-rc1
  // e214ea5b94f345b66f302d0d4aae232b4128c1e3  refs/tags/7.x-1.0-rc2
  // 8f61c66e5f55e72a35f4a1b8f4eee93a428a03ac  refs/tags/7.x-1.0-rc3
  $command = "git ls-remote --tags {$details['uri']}";

  // Each line of output is stored in $output array.
  // $exit_code is 0 for success, anything else for failure.
  exec($command, $output, $exit_code);

  // Handle failure.
  if ($exit_code !== 0) {
    return drush_set_error('drushsubtree', dt("Request for remote tag list failed: !command", array('!command' => $command)));
  }

  // Parse result.
  $tags = array();
  foreach ($output as $line) {
    // Example line: 8f61c66e5f55e72a35f4a1b8f4eee93a428a03ac  refs/tags/7.x-1.0
    $parts = explode("\t", $line);
    if (count($parts) < 2) {
      // Skip empty lines that sneak in.
      continue;
    }
    $pos = strlen('refs/tags/');
    $tag = substr($parts[1], $pos);
    $id = $parts[0];
    $tags[$tag] = $id;
  }

  return $tags;
}

/**
 * Get tag/version for a project specified in make file(s).
 *
 * @param string $project_name
 *   Name of project (module, profile, theme, library).
 *
 * @param array $project_info
 *   Project info array from make files.
 *
 * @return string
 *   Project version number specified in make file. Empty if unavailable.
 */
function _drushsubtree_get_project_tag($project_name, $project_info) {
  $tag = '';

  if (isset($project_info['version'])) {
    $tag = $project_info['version'];
  }
  elseif (isset($project_info['download']['tag'])) {
    $tag = $project_info['download']['tag'];
  }
  else {
    // Make files do not specify any tag for this project.
    drush_log(dt("No tag or commit ID available for !name.",
                  array('!name' => $project_name), 'warning'));
  }

  return $tag;
}

/**
 * Return command to generate symlink to subtree.
 *
 * This command must be run from top-level of repo.
 *
 * @param string $name
 *   Name of project (module, theme, profile) to be replaced with a symlink to a
 *   subtree inside /projects.
 *
 * @param string $path
 *   Path to project in Drupal code base, relative to top-level of site repo.
 *
 * @return string
 *   Shell command for adding symlink.
 */
function _drushsubtree_subtree_add_symlink($name, $path) {
  // Get path to subtree, relative to top-level directory.
  $prefix = _drushsubtree_get_prefix($name);

  // Get source, relative to parent directory inside docroot.
  $count = count(explode('/', $path));
  $source = '';
  for ($i = 0; $i < $count - 1; $i++) {
    $source .= '../';
  };
  // Add prefix to relative source path.
  $source .= $prefix;

  // Parent directory for symlink.
  $pos = strpos($path, $name);
  $parent_directory = substr($path, 0, $pos);

  // Remove the directory. Replace it with a symlink.
  $command = "rm -rf {$path}; cd {$parent_directory}; ln -s {$source} {$name};";

  return $command;
}

/**
 * Implements hook_buildmanager_build().
 *
 * Check for subtrees in config file. Add/update subtrees in build.
 *
 * param array $info
 *   Info from drush make build file.
 *
 * param array $config
 *   Configuration defined in buildmanager.config.yml
 *
 * param obj $commands
 *   Commands to be executed by buildmanager.
 *   - precommands (array), commands to execute before `drush make` (re)build
 *   - postcommands (array), commands to execute after `drush make` (re)build
 */
function drushsubtree_buildmanager_build($info, $config, $commands) {
  // Check for subtrees in $config.
  if (!isset($config['subtrees'])) {
    // This project has no subtrees. Our work here is done.
    return;
  }

  // @todo Check if there are uncommitted changes locally. Exit if there are.
  // Otherwise, subtree add/pull won't work.
  // If there are subtrees in the config file, get commands for adding/updating
  // subtrees.

  drush_log(dt('Preparing to add/update git subtrees.'), 'ok');

  // Prep projects directory. All subtrees will use --prefix=projects/$name
  _drushsubtree_prep_projects_directory();

  // Get subtree commands to be executed before running `drush make`.
  $subtree_commands = array();

  // Get symlink commands to be run after `drush make`.
  $symlink_commands = array();

  // Loop through subtrees twice. Repo updates are done as prebuild commands.
  // Symlinks (which will get blown away by drush make) should be restored as
  // postbuild commands.
  foreach ($config['subtrees'] as $subtree_name => $details) {

    // Start with postbuild commands (adding symlinks) because prebuild commands
    // are sometimes skipped (when no-subtree-updates flag is set).
    // Remove files checked out by drush. Add symlink pointing to local subtree.
    drush_log(dt('Preparing to symlink !subtree_name to path: !path', array('!subtree_name' => $subtree_name, '!path' => $details['path'])), 'ok');
    $symlink_commands[] = _drushsubtree_subtree_add_symlink($subtree_name, $details['path']);

    // Next add do prebuild commands / subtree repo updates.
    if (drush_get_option('no-subtree-updates', FALSE)) {
      // If no-subtree-updates flag is set, skip the rest of the foreach loop.
      drush_log(dt('Skipping git subtree updates.'), 'ok');
      continue;
    }

    // Instantiate new commander to generate subtree commands.
    $subtree = new SubtreeCommander($subtree_name, $details);

    // Collect commands as $subtree_commands, then add them all to the
    // beguinning of $commands->prebuild array.
    // It's important these run before drush make for
    // two reasons: (1) Incase a project's build file includes a make file in a
    // subtree project. This will ensure the updated make file is included in
    // the build. (2) This needs to run before anything else dirties the working
    // tree (like drush make), otherwise the subtree add/pull/merge will fail.
    // First, add git subtree if it doesn't already exist.
    if ($subtree_add = $subtree->add(TRUE)) {
      drush_log(dt('Preparing to add subtree: !subtree_name',
             array('!subtree_name' => $subtree_name)), 'ok');
      $subtree_commands[] = $subtree_add;
    }
    // Otherwise, pull in any updates.
    elseif ($subtree_pull = $subtree->pull()) {
      $subtree_commands[] = $subtree_pull;
    }

    // Use git subtree merge to check out a particular version of a project.
    // First get the git commit ID to merge to using info from make files.
    $project_info = $info['projects'][$subtree_name];
    $tag = _drushsubtree_get_project_tag($subtree_name, $project_info);
    $id = _drushsubtree_get_project_id($subtree_name, $project_info,
                                       $details, $tag);
    if ($id) {
      $subtree_commands[] = $subtree->merge($id, $tag);
    }
    else {
      // @todo Detect latest recommended release on d.o when no version is
      // specified. Consider using that to better match standard make file
      // behavior?
      drush_log(dt("No commit ID specified for !project (if a tag was specified in a make file, the corresponding commit ID could not be retrieved). Your install will run on the tip of whatever branch you checked out. (Subtrees do not fallback to the latest recommended release on drupal.org when no version is specified.)", array('!project' => $subtree_name)), 'warning');
    }

    // End loop thorugh subtrees.
  }

  // Add symlink commands after drush make but before other commands, incase any
  // custom post-build commands are committing anything. This way, git history
  // doesn't get polluted with projects being re-added and re-removed each time.
  $commands->postbuild = array_merge($symlink_commands, $commands->postbuild);

  // Now add all subtree_commands to begining of prebuild command list.
  $commands->prebuild = array_merge($subtree_commands, $commands->prebuild);

  // No return necessary. Commands added to $command object are available to
  // buildmaster_build command now.
}

/**
 * Prep projects directory.
 */
function _drushsubtree_prep_projects_directory() {
  // Before adding/pulling subtrees, make sure parent directory
  // for --prefix exists.
  if (!file_exists('projects')) {
    $success = mkdir('projects', 0777, TRUE);
    if (!$success) {
      return drush_set_error('buildmanager', dt("Failed creating directory: projects"), 'error');
    }
  }
  elseif (file_exists('projects') && !is_dir('projects')) {
    return drush_set_error('buildmanager', dt("Please remove the 'projects' file. We need to create a directory with that name for your subtrees."), 'error');
  }

  if ($success) {
    drush_log(dt('A projects directory has been created at the top of your git repo. Git subtrees will be added there.'), 'ok');
  }
}

/**
 * Implements hook_buildmanager_build_options().
 */
function drushsubtree_buildmanager_build_options() {
  return array(
    'no-subtree-updates' => array(
      'description' => 'Do add/pull/merge subtrees in buildmanager config.',
    ),
    // @todo
    're-add' => array(
      'description' => '@todo Remove and re-add comma separated list of subtree(s).',
    ),
  );
}

/**
 * Implements hook_buildmanager_configure().
 *
 * Prompt for subtree info to be included in buildmanager config.
 * Returns config with subtree properties added, to be included in
 * buildmanager.config.yml.
 *
 * param array $config
 *   See hook_buildmanager_configure.
 *
 * pararm bool $prompt
 *   Ask user if project includes subtrees.
 */
function drushsubtree_buildmanager_configure($config, $prompt = TRUE) {
  if ($prompt && drush_confirm("\n" . dt("Does your build include subtrees?")) == FALSE) {
    // Our work here is done. Return unmodified $config array.
    return $config;
  }
  else {
    drush_print("\n" . dt("I'll help you set up configuration for subtrees. Later when Build Manager prompts you for info about symlinks, don't worry about your subtrees. Drush Subtree will take care of setting up and restoring those symlinks for you when Build Manager (re)builds."));
  }

  drush_print("\n" . dt("subtree properties..."));
  drush_print(dt("Tell me about any subtrees included in this build one-by-one."));
  $subtrees = array();
  $get_subtrees = TRUE;
  // Get subtree properties.
  while ($get_subtrees) {
    $name = drush_prompt(dt("What's the name of your subtree"));

    drush_print(dt("Please enter the path to the project in your codebase (e.g. docroot/sites/all/modules/custom/my-project)"));
    $subtrees[$name]['path'] = drush_prompt("path");

    drush_print(dt("Repo URI"));
    $subtrees[$name]['uri'] = drush_prompt("uri");

    drush_print(dt("Branch to pull from and push to"));
    $subtrees[$name]['branch'] = drush_prompt(dt("branch"));

    drush_print(dt("(Optional) Add a standard commit message to be included in any subtree add/pull/merge commits."));
    $default_message = "{$name} subtree from {$subtrees[$name]['uri']}";
    $subtrees[$name]['message'] = drush_prompt(dt("message"), $default_message);

    // Continue collecting info about more subtrees?
    $get_subtrees = drush_confirm(dt("Does your build include any more subtrees?"));
  }

  // Show subtree properties to user. Confirm they're right.
  // Show commands to user. Confirm they're right.
  drush_print("\n" . dt("Here are the subtree properties you entered:" . "\n"));
  drush_print(drush_format($subtrees, NULL, 'yaml'));
  if (!drush_confirm("Are these properties correct?")) {
    // Do over.
    $subtrees = drushsubtree_buildmanager_configure($config);
  }

  // Set subtrees property in Build Manager config file.
  $config['subtrees'] = $subtrees;
  return $config;
}

/**
 * Callback for drushsubtree-add (subtree-add).
 *
 * @param string $name
 *   Name of subtree.
 */
function drush_drushsubtree_subtree_add($name = '') {
  // Get buildmanager config.
  $config = _drushsubtree_get_config();

  // Get name if not passed as argument.
  if (!$name) {
    $name = _drushsubtree_get_name($config);
  }

  // Generate subtree add command and execute it.
  if (!isset($config['subtrees'][$name])) {
    drush_log(dt('Sorry. No properties for a subtree with this name could be found in your config file: !name',
      array('!name' => $name)), 'error');
  }

  // Generate subtree add command and execute it.
  $properties = $config['subtrees'][$name];
  $subtree = new SubtreeCommander($name, $properties);
  if ($subtree_add = $subtree->add()) {
    _drushsubtree_shell_exec($subtree_add);
  }
}

/**
 * Find, parse, return buildmanager config.
 *
 * @return array
 *   Parsed buildmanager.config.yml.
 */
function _drushsubtree_get_config() {
  if (!function_exists('buildmanager_get_config_file')) {
    return drush_set_error('drushsubtree', dt('Missing Drush dependency: Build Manager'));
  }

  // First check for --config_file=path/to/buildmanager.config.yml flag.
  if (!$config_file = drush_get_option('config_file', '')) {
    // If not specified, buildmanager will check for a config file or prompt for
    // selection if many are found in top-level directory of repo.
    $config_file = buildmanager_get_config_file();
  }
  // Now parse config file.
  $config = buildmanager_get_config($config_file);

  return $config;
}

/**
 * Callback for drush drushsubtree-checkout (subtree-checkout).
 *
 * Faux subtree command. Works like `git checkout <id>` or `git checkout <tag>`.
 *
 * @param string $name
 *   Subtree name.
 *
 * @param string $ref
 *   Git commit ID or tag.
 */
function drush_drushsubtree_subtree_checkout($name, $ref) {
  // Get buildmanager config.
  $config = _drushsubtree_get_config();

  // Make sure there are subtrees in config.
  if (!isset($config['subtrees'])) {
    return drush_set_error(dt('No subtrees found in buildmanager config file.'));
  }
  // Make sure named subtree is there.
  elseif (!isset($config['subtrees'][$name])) {
    return drush_set_error(
      dt('No subtree with this name found in buildmanager config file: !name',
      array('!name' => $name))
    );
  }
  else {
    // Grab project properties from config.
    $properties = $config['subtrees'][$name];
  }

  // Determine if $ref is a tag or a commit ID. (This check is pretty
  // unsophistocated. If $ref is 40 characters, assume it's a commit ID,
  // otherwise it's a tag.) Then get/set $id so we can do a subtree merge to
  // "checkout" the desired tag/id.
  (strlen($ref) == 40) ? $id = $ref : $tag = $ref;
  if ($tag) {
    // It's not 40 characters (not a SHA1), assume $ref is a tag.
    $project_info = buildmanager_get_project_info($name, $config);
    $id = _drushsubtree_get_project_id($name, $project_info, $properties, $ref);
  }

  drush_print(dt('Note: "checkout" is not a real subtree command. This is really just a friendly wrapper around subtree merge.'), 'notice');

  $subtree = new SubtreeCommander($name, $properties);
  _drushsubtree_shell_exec($subtree->merge($id, $tag));
}

/**
 * Callback for drushsubtree-pull (subtree-pull).
 *
 * @param string $name
 *   Name of subtree.
 */
function drush_drushsubtree_subtree_pull($name = '') {
  // Get buildmanager config.
  $config = _drushsubtree_get_config();

  // Get name if not passed as argument.
  if (!$name) {
    $name = _drushsubtree_get_name($config);
  }

  $properties = $config['subtrees'][$name];
  $subtree = new SubtreeCommander($name, $properties);
  _drushsubtree_shell_exec($subtree->pull());
}

/**
 * Callback for drushsubtree-merge (subtree-merge).
 *
 * @param string $name
 *   Optional name of subtree to merge.
 *
 * @param string $id
 *   Optional commit id to merge to.
 */
function drush_drushsubtree_subtree_merge($name = '', $id = '') {
  // Get buildmanager config.
  $config = _drushsubtree_get_config();

  // Get name if not passed as argument.
  if (!$name) {
    $name = _drushsubtree_get_name($config);
  }

  // Get project info from make file(s).
  $project_info = buildmanager_get_project_info($name, $config);

  // Get git tag and id.
  $properties = $config['subtrees'][$name];
  if (!$id) {
    $tag = _drushsubtree_get_project_tag($name, $project_info);
    $id = _drushsubtree_get_project_id($name, $project_info, $properties, $tag);
  }

  $subtree = new SubtreeCommander($name, $properties);
  _drushsubtree_shell_exec($subtree->merge($id, $tag));
}

/**
 * Callback for drushsubtree-push (subtree-push).
 *
 * @param string $name
 *   Name of subtree.
 */
function drush_drushsubtree_subtree_push($name) {
  // Get buildmanager config.
  $config = _drushsubtree_get_config();

  // Get name if not passed as argument.
  if (!$name) {
    $name = _drushsubtree_get_name($config);
  }

  $properties = $config['subtrees'][$name];
  $subtree = new SubtreeCommander($name, $properties);
  _drushsubtree_shell_exec($subtree->push());
}

/**
 * Prompt user to select subtree from options in config file.
 *
 * TODO If only one, use that, no prompt. Notify user decision has been made.
 *
 * @param array $config
 *   Parsed config from buildmanager config file.
 *
 * @return string
 *   Name of subtree
 */
function _drushsubtree_get_name($config) {
  $names = array_keys($config['subtrees']);
  $names = array_combine($names, $names);
  $name = drush_choice($names, dt('Select a subtree to pull:'));
  return $name;
}

/**
 * Callback for drushsubtree (subtree) command.
 *
 *     drush subtree <command> <name> [<args>,...]
 */
function drush_drushsubtree_subtree() {
  // Get $args and build array to pass to subtree command.
  $args = func_get_args();
  if (!$args) {
    // When no args are passed, return help (like `git subtree`).
    $command = 'drush subtree --help';
    $output = shell_exec($command);
    drush_print($output);
    return;
  }

  // Remove $command (arg0).
  $command = array_shift($args);

  // Name of function to call for desired drushsubtree command.
  $function = 'drush_drushsubtree_subtree_' . $command;

  // Call drush subtree <command> [<args>,...].
  call_user_func_array($function, $args);
}

/**
 * Wrapper around drush_shell_exec for standard error reporting.
 *
 * @param string $command
 *   Command to be executed.
 *
 * @return bool
 *   Succes/fail based on drush_shell_exec result.
 */
function _drushsubtree_shell_exec($command) {
  $success = drush_shell_exec($command);
  if (!$success) {
    // Command failed. Notify user and exit.
    drush_log(dt('Command failed: !command', array('!command' => $command)), 'error');
    $output = implode("\n", drush_shell_exec_output());
    return drush_set_error($output);
  }
  return $success;
}
